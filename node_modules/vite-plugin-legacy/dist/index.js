'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var commonJS = require('@rollup/plugin-commonjs');
var dedent2 = require('dedent');
var babel = require('@babel/core');
var chalk2 = require('chalk');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var commonJS__default = /*#__PURE__*/_interopDefaultLegacy(commonJS);
var dedent2__default = /*#__PURE__*/_interopDefaultLegacy(dedent2);
var babel__default = /*#__PURE__*/_interopDefaultLegacy(babel);
var chalk2__default = /*#__PURE__*/_interopDefaultLegacy(chalk2);

const knownPolyfills = [
  "AbortController",
  "AudioContext",
  "CSS.supports",
  "IntersectionObserver",
  "Intl",
  "MutationObserver",
  "Reflect",
  "ResizeObserver",
  "fetch",
  "globalThis",
  "queueMicrotask",
  "requestIdleCallback"
];

var plugin = (config = {}) => {
  return {
    name: "vite:legacy",
    apply: "build",
    enforce: "pre",
    configResolved(viteConfig) {
      let entryChunks;
      let legacyChunks = new Map();
      this.generateBundle = async function(_, bundle) {
        entryChunks = Object.values(bundle).filter((asset) => asset.type == "chunk" && asset.isEntry);
        viteConfig.logger.info(chalk2__default['default'].cyan("creating legacy bundle..."));
        for (const entryChunk of entryChunks) {
          const legacyChunk = await createLegacyChunk(entryChunk, config, viteConfig);
          bundle[legacyChunk.fileName] = legacyChunk;
          legacyChunks.set(entryChunk, legacyChunk);
        }
      };
      const target = resolveTarget(config, viteConfig);
      const renderScript = createScriptFactory(target, config);
      const getBasePath = (fileName) => viteConfig.base + fileName;
      this.transformIndexHtml = (html) => html.replace(/<script type="module" src="([^"]+)"><\/script>/g, (match, moduleId) => {
        const entryChunk = entryChunks.find((entryChunk2) => moduleId == getBasePath(entryChunk2.fileName));
        const legacyChunk = entryChunk && legacyChunks.get(entryChunk);
        return legacyChunk ? renderScript(moduleId, getBasePath(legacyChunk.fileName), !config.corejs && /\bregeneratorRuntime\b/.test(legacyChunk.code)) : match;
      });
    }
  };
};
const regeneratorUrl = "https://cdn.jsdelivr.net/npm/regenerator-runtime@0.13.7";
const syntaxTests = {
  es2018: "void ({...{}}, /0/s, async function*(){})",
  es2019: "try{} catch{}",
  es2020: "0?.$"
};
const getBabelEnv = ({
  targets = "defaults",
  ignoreBrowserslistConfig,
  corejs
}) => ({
  bugfixes: true,
  useBuiltIns: corejs && "usage",
  corejs: corejs ? 3 : void 0,
  targets,
  ignoreBrowserslistConfig
});
function createScriptFactory(target, config) {
  const polyfills2 = (config.polyfills || []).filter((name) => {
    if (!knownPolyfills.includes(name)) {
      throw Error(`Unknown polyfill: "${name}"`);
    }
    return true;
  }).sort();
  if (!config.corejs) {
    const targetYear = parseTargetYear(target);
    for (let year = Math.min(targetYear, 2019); year >= 2015; --year) {
      polyfills2.unshift("es" + year);
    }
  }
  const polyfillHost = "https://polyfill.io/v3/polyfill.min.js?version=3.53.1";
  const polyfillScript = polyfills2.length > 0 && `load('${polyfillHost}&features=${polyfills2.join(",")}')`;
  const syntaxTest = syntaxTests[target];
  const moduleTest = "script.noModule.$";
  return (modernBundleId, legacyBundleId, needsRegenerator) => dedent2__default['default']`
    <script>
      (function() {
        var script = document.createElement('script')
        function load(src, type) {
          var s = script.cloneNode()
          if (type) s.type = type
          s.src = src
          document.head.appendChild(s)
        }
        try {
          ${joinLines(moduleTest, syntaxTest && `eval('${syntaxTest}')`, `load('${modernBundleId}', 'module')`)}
        } catch(e) {
          ${joinLines(polyfillScript, needsRegenerator && `load('${regeneratorUrl}')`, `load('${legacyBundleId}')`)}
        }
      })()
    </script>
  `;
}
function joinLines(...lines) {
  return lines.filter(Boolean).join("\n");
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function resolveTarget(config, viteConfig) {
  let result = config.ecmaVersion;
  if (!result) {
    let {target} = viteConfig.build;
    if (!target) {
      target = typeof viteConfig.esbuild !== "function" && (viteConfig.esbuild || {}).target;
    }
    if (target) {
      result = toArray(target).find((value) => /^es\d+$/i.test(value));
    }
  }
  if (result && /^es\d+$/i.test(result)) {
    return result.toLowerCase();
  }
  return "es2020";
}
function parseTargetYear(target) {
  if (target == "es5" || target == "esnext") {
    throw Error('[vite-legacy] Unsupported "esbuildTarget" value: ${target}');
  }
  const version = Number(/\d+/.exec(target)[0]);
  return version + (version < 2e3 ? 2009 : 0);
}
async function createLegacyChunk(mainChunk, config, viteConfig) {
  var _a;
  const viteBuild = viteConfig.build;
  const transformed = await babel__default['default'].transformAsync(mainChunk.code, {
    configFile: false,
    inputSourceMap: (_a = mainChunk.map) != null ? _a : void 0,
    sourceMaps: viteBuild.sourcemap,
    presets: [[require("@babel/preset-env"), getBabelEnv(config)]],
    plugins: !config.corejs ? [require("@babel/plugin-transform-regenerator")] : null
  });
  const {code, map} = transformed || {};
  if (!code) {
    throw Error("[vite-plugin-legacy] Failed to transform modern bundle");
  }
  const legacyPath = mainChunk.fileName.replace(/\.js$/, ".legacy.js");
  const legacyPlugins = [];
  if (config.corejs)
    legacyPlugins.push(commonJS__default['default']({
      sourceMap: !!viteBuild.sourcemap
    }));
  legacyPlugins.push({
    name: "vite-legacy:resolve",
    resolveId(id) {
      if (id == legacyPath)
        return id;
      if (/^(core-js|regenerator-runtime)\//.test(id)) {
        return require.resolve(id);
      }
    },
    load(id) {
      if (id == legacyPath) {
        return {code, map};
      }
    }
  });
  if (viteBuild.minify)
    legacyPlugins.push(require("rollup-plugin-terser").terser(viteBuild.terserOptions));
  const rollup2 = require("rollup").rollup;
  const bundle = await rollup2({
    input: legacyPath,
    plugins: legacyPlugins
  });
  const {output} = await bundle.generate({
    entryFileNames: legacyPath,
    format: "iife",
    sourcemap: viteBuild.sourcemap,
    sourcemapExcludeSources: true,
    inlineDynamicImports: true
  });
  return output[0];
}

exports.default = plugin;
//# sourceMappingURL=index.js.map
